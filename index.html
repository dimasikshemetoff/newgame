<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2.5D Сборщик Фруктов</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #ui {
            position: fixed;
            top: 10px;
            font-size: 18pt;
            font-weight: bold;
            text-transform: uppercase;
            left: 10px;
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #ui div {
            margin-bottom: 5px;
        }
        #timeLeft {
            font-size: 1.2em;
            font-weight: bold;
            text-shadow: 0 0 5px rgb(255, 145, 0);
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #333;
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            max-width: 500px;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin: 12px 0 6px 0;
        }
        .legend-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 90px;
        }
        .legend-img {
            width: 64px;
            height: 64px;
            object-fit: cover;
            border-radius: 8px;
            box-shadow: 0 0 6px rgba(0,0,0,0.4);
            background: #222;
        }
        /* Изображение шипа в виде треугольника */
        .spike-icon {
            width: 64px;
            height: 64px;
            object-fit: cover;
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
            filter: drop-shadow(0 0 6px rgba(255,0,0,0.6));
        }
        .modal h2 {
            margin-bottom: 15px;
            color: #ff5555;
        }
        .modal p {
            margin-bottom: 20px;
            font-size: 18px;
        }
        .modal button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            margin: 5px;
        }
        .modal button:hover {
            background-color: #45a049;
        }
        #notification {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 24px;
            z-index: 200;
            display: none;
            text-align: center;
            max-width: 80%;
        }

        #timeContainer{
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translatex(-50%);
            font-size: 20pt;
            display: flex;
            flex-direction: column;
            text-align: center;
            font-weight: bold;
            color: #ffcc00;
            text-transform: uppercase;
        }
        
        /* Стили для модального окна информации о комнате */
        #roomInfoModal {
            z-index: 1500;
        }
        #roomInfoModal .modal-content {
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #ffcc00;
            padding: 30px;
        }
        #roomInfoModal h2 {
            color: #ffcc00;
            font-size: 32px;
            margin-bottom: 20px;
        }
        #roomInfoModal p {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        /* Стили для модального окна паузы */
        #pauseModal {
            z-index: 1500;
        }
        #pauseModal .modal-content {
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #4CAF50;
            padding: 30px;
        }
        #pauseModal h2 {
            color: #4CAF50;
            font-size: 32px;
            margin-bottom: 20px;
        }
        #pauseModal .pause-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }
        #pauseModal .pause-options button {
            width: 100%;
            padding: 12px;
            font-size: 18px;
        }
        #pauseModal .sound-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin-bottom: 10px;
        }
        #pauseModal .sound-toggle label {
            font-size: 18px;
        }
        #pauseModal .sound-toggle input {
            width: 20px;
            height: 20px;
        }
        
        /* Стили для таблицы лидеров */
        #leaderboard {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        #leaderboard th, #leaderboard td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        #leaderboard th {
            color: #ffcc00;
            font-size: 18px;
        }
        #leaderboard td {
            font-size: 16px;
        }
        
        /* Анимация пульсации для таймера */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div>Комната: <span id="roomNumber">1</span></div>
        <div>Фрукты: <span id="collectedFruits">0</span>/<span id="requiredFruits">5</span></div>
        
    </div>
        <div id="timeContainer">Осталось: <span id="timeLeft">60</span></div>
    
    
    <!-- Intro Modal -->
    <div id="introModal" class="modal">
        <div class="modal-content">
            <h2>Как играть</h2>
            <p>Привет! Это БолБолыч.</p>
            <p>Твоя цель — собрать нужное количество фруктов, чтобы открыть ворота и перейти в следующую комнату.</p>
            <p>Управление:</p>
            <p>W A S D — движение, Мышь — повернуть камеру, Пробел — прыгнуть.</p>
            <div class="legend">
                <div class="legend-item">
                    <img class="spike-icon" src="spike.jpg" alt="Шип" />
                    <div class="legend-label">Шип — опасно</div>
                </div>
                <div class="legend-item">
                    <img class="legend-img" src="apple.jpg" alt="Яблоко" style="transform: rotate(90deg); border-radius: 50%;"/>
                    <div class="legend-label">Яблоко</div>
                </div>
                <div class="legend-item">
                    <img class="legend-img" src="orange.jpg" alt="Апельсин" style="transform: rotate(90deg); border-radius: 50%;"/>
                    <div class="legend-label">Апельсин</div>
                </div>
                <div class="legend-item">
                    <img class="legend-img" src="pear.jpg" alt="Груша" style="transform: rotate(90deg); border-radius: 50%;"/>
                    <div class="legend-label">Груша</div>
                </div>
                <div class="legend-item">
                    <img class="legend-img" src="speed.png" alt="Ускорение" style="transform: rotate(90deg); border-radius: 50%;" />
                    <div class="legend-label">Ускорение</div>
                </div>
                <div class="legend-item">
                    <img class="legend-img" src="scalability.png" alt="Увеличение" style="transform: rotate(90deg); border-radius: 50%;"  />
                    <div class="legend-label">Стань больше</div>
                </div>
                <div class="legend-item">
                    <img class="legend-img" src="down.png" alt="Уменьшение" style="transform: rotate(90deg); border-radius: 50%;"/>
                    <div class="legend-label">Стань меньше</div>
                </div>
            </div>
            <button id="introOkButton">Понятно!</button>
        </div>
    </div>
    
    <!-- Room Info Modal -->
    <div id="roomInfoModal" class="modal">
        <div class="modal-content">
            <h2 id="roomInfoTitle">Комната 1</h2>
            <p id="roomInfoGoal">Цель: 5 фруктов</p>
            <p id="roomInfoTime">Время: 60 секунд</p>
        </div>
    </div>
    
    <!-- Pause Modal -->
    <div id="pauseModal" class="modal">
        <div class="modal-content">
            <h2>Пауза</h2>
            <div class="sound-toggle">
                <label for="soundToggle">Звук:</label>
                <input type="checkbox" id="soundToggle" checked>
            </div>
            <div class="pause-options">
                <button id="resumeButton">Продолжить</button>
                <button id="restartFromPauseButton">Начать заново</button>
                <button id="leaderboardButton">Таблица лидеров</button>
            </div>
            <div id="leaderboardContainer" style="display: none; margin-top: 20px;">
                <h3>Таблица лидеров</h3>
                <table id="leaderboard">
                    <thead>
                        <tr>
                            <th>Место</th>
                            <th>Комната</th>
                            <th>Фрукты</th>
                            <th>Время</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboardBody">
                        <!-- Данные таблицы будут добавлены через JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="gameOverModal" class="modal">
        <div class="modal-content">
            <h2>Игра окончена!</h2>
            <p id="gameOverMessage">Вы коснулись шипов и потеряли весь прогресс!</p>
            <button id="restartButton">Начать заново</button>
        </div>
    </div>
    
    <!-- Notification -->
    <div id="notification"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Настройка сцены
        const scene = new THREE.Scene();
        
        // Загрузка текстуры неба
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load('sky.jpg', function(texture) {
            scene.background = texture;
        }, undefined, function(error) {
            console.error('Ошибка загрузки sky.jpg:', error);
            // Резервный цвет неба в случае ошибки загрузки
            scene.background = new THREE.Color(0x87CEEB); 
        });
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Улучшенные тени

        // Обработка ресайза
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Освещение
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 15);
        directionalLight.castShadow = true;
        // Улучшенные настройки теней
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        scene.add(directionalLight);

        // Позиция камеры
        camera.position.set(0, 8, 12);
        camera.lookAt(0, 0, 0);
        // Плавное сглаживание позиции камеры
        let cameraSmoothPos = camera.position.clone();

        // Глобальные материалы/текстуры и статическая геометрия
        const staticGroup = new THREE.Group();
        scene.add(staticGroup);
        let staticBuilt = false;
        const sharedTextures = { floor: null, wall: null, wood: null, spike: null };
        const sharedMaterials = { floor: null, wall: null, wood: null, spike: null };

        // Предзагрузка общих текстур и создание материалов один раз
        try {
            sharedTextures.floor = textureLoader.load('plate.jpg');
        } catch (e) {
            console.warn('Failed to load floor texture, using default');
            sharedTextures.floor = null;
        }
        try {
            sharedTextures.wall = textureLoader.load('stone.jpg');
        } catch (e) {
            console.warn('Failed to load wall texture, using default');
            sharedTextures.wall = null;
        }
        try {
            sharedTextures.wood = textureLoader.load('wood.jpg');
        } catch (e) {
            console.warn('Failed to load wood texture, using default');
            sharedTextures.wood = null;
        }
        try {
            sharedTextures.spike = textureLoader.load('spike.jpg');
        } catch (e) {
            console.warn('Failed to load spike texture, using default');
            sharedTextures.spike = null;
        }
        
        sharedMaterials.floor = new THREE.MeshStandardMaterial({ map: sharedTextures.floor, roughness: 0.8 });
        sharedMaterials.wall = new THREE.MeshStandardMaterial({ map: sharedTextures.wall, roughness: 0.9 });
        sharedMaterials.wood = new THREE.MeshStandardMaterial({ map: sharedTextures.wood, roughness: 0.8 });
        sharedMaterials.spike = new THREE.MeshStandardMaterial({ map: sharedTextures.spike, roughness: 0.5 });
        
        // Создание разноцветной текстуры для мяча
        function createRainbowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Создаем градиентную текстуру
            const gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#ff0000');
            gradient.addColorStop(0.17, '#ff9900');
            gradient.addColorStop(0.33, '#ffff00');
            gradient.addColorStop(0.5, '#00ff00');
            gradient.addColorStop(0.67, '#00ffff');
            gradient.addColorStop(0.83, '#0000ff');
            gradient.addColorStop(1, '#9900ff');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            return new THREE.CanvasTexture(canvas);
        }
        
        // Материал мяча: пытаемся загрузить ball.jpg, иначе радужная текстура
        function createBallMaterial() {
            try {
                const ballTexture = textureLoader.load('ball.jpg');
                return new THREE.MeshStandardMaterial({ 
                    map: ballTexture,
                    flatShading: false,
                    roughness: 0.3,
                    metalness: 0.2
                });
            } catch (e) {
                return new THREE.MeshStandardMaterial({ 
            map: createRainbowTexture(),
            flatShading: false,
            roughness: 0.3,
            metalness: 0.2
        });
            }
        }
        
        // Игрок (шар)
        let playerRadius = 0.5;
        const playerGeometry = new THREE.SphereGeometry(playerRadius, 32, 32);
        const playerMaterial = createBallMaterial();
        let player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.set(0, playerRadius, 0);
        player.castShadow = true;
        scene.add(player);
        
        // Инерция движения
        const velocity = new THREE.Vector3();
        const acceleration = 0.02;
        const friction = 0.92;
        let maxSpeed = 0.2;
        const bounceForce = 0.5;
        
        // Прыжки и гравитация
        const gravity = -0.01;
        let jumpVelocity = 0.2;
        let isJumping = false;
        let verticalVelocity = 0;
        // Отскок от земли
        const groundBounceFactor = 0.6; // коэффициент упругости при ударе о землю
        const minImpactSpeedForBounce = 0.12; // минимальная скорость падения для отскока
        const minPostBounceSpeed = 0.001; // если после отскока скорость меньше — гасим
        // Анимация сплющивания при отскоке
        let squashActive = false;
        const squashBaseScale = new THREE.Vector3(1, 1, 1);
        function triggerSquashStretch(impactSpeed) {
            // Относительная интенсивность
            const t = THREE.MathUtils.clamp(Math.abs(impactSpeed) / 0.4, 0.2, 1.0);
            squashBaseScale.copy(player.scale);
            const sy = 1 - 0.25 * t; // сжимаем только по вертикали
            player.scale.set(squashBaseScale.x, squashBaseScale.y * sy, squashBaseScale.z);
            squashActive = true;
        }
        function updateSquash() {
            if (squashActive) {
                // Плавно возвращаемся к базовому масштабу
                player.scale.lerp(squashBaseScale, 0.15);
                if (player.scale.distanceTo(squashBaseScale) < 0.005) {
                    player.scale.copy(squashBaseScale);
                    squashActive = false;
                }
            }
        }
        
        // Двойной прыжок
        let jumpCount = 1;
        const maxJumps = 2;
        
        // Управление клавиатурой
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            // Прыжок по пробелу
            if (e.key === ' ' && jumpCount > 0) {
                verticalVelocity = jumpVelocity;
                isJumping = true;
                jumpCount--;
                
                // Воспроизводим звук прыжка
                if (sounds.jump && soundEnabled) {
                    playSound(sounds.jump);
                }
            }
            
            // Пауза по клавише Q
            if (e.key.toLowerCase() === 'q' || e.key.toLowerCase() === 'й' && isGameRunning) {
                togglePause();
            }
        });
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        // Управление камерой мышью
        let mouseX = 0;
        let mouseY = 0;
        let isMouseLocked = false;
        let cameraDistance = 10;
        let cameraHeight = 8;
        
        document.addEventListener('click', () => {
            const introVisible = document.getElementById('introModal')?.style.display === 'flex';
            const gameOverVisible = document.getElementById('gameOverModal')?.style.display === 'flex';
            const pauseVisible = document.getElementById('pauseModal')?.style.display === 'flex';
            const roomInfoVisible = document.getElementById('roomInfoModal')?.style.display === 'flex';
            if (introVisible || gameOverVisible || pauseVisible || roomInfoVisible) return; // не фиксируем курсор при открытых модалках
            document.body.requestPointerLock();
        });
        
        document.addEventListener('pointerlockchange', () => {
            isMouseLocked = document.pointerLockElement === document.body;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isMouseLocked) return;
            
            mouseX += e.movementX * 0.002;  // Изменено на минус для инверсии по горизонтали
            mouseY -= e.movementY * 0.002;  // Изменено на плюс для инверсии по вертикали
            
            // Ограничиваем угол вращения по вертикали
            mouseY = Math.max(-Math.PI/3, Math.min(Math.PI/6, mouseY));
        });
        
        // Управление колесиком мыши для приближения/отдаления
        document.addEventListener('wheel', (e) => {
            if (!isMouseLocked) return;
            
            // Изменяем расстояние камеры
            cameraDistance += e.deltaY * 0.01;
            
            // Ограничиваем минимальное и максимальное расстояние
            cameraDistance = Math.max(0.2, Math.min(20, cameraDistance));
        });

        // Звуковая система
        let audioContext;
        const sounds = {};
        let soundEnabled = true;

        // Инициализация AudioContext
        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        // Загрузка звука
        function loadSound(url) {
            return new Promise((resolve, reject) => {
                const request = new XMLHttpRequest();
                request.open('GET', url, true);
                request.responseType = 'arraybuffer';
                request.onload = function() {
                    audioContext.decodeAudioData(request.response, function(buffer) {
                        resolve(buffer);
                    }, function(e) {
                        reject(e);
                    });
                };
                request.onerror = reject;
                request.send();
            });
        }

        // Воспроизведение звука
        function playSound(buffer) {
            if (!audioContext || !buffer || !soundEnabled) return;
            
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.start(0);
        }

        // Загрузка всех звуков
        async function loadAllSounds() {
            try {
                // В реальном приложении укажите правильные пути к файлам
                sounds.collect = await loadSound('collect.mp3');
                sounds.jump = await loadSound('jump.mp3');
                sounds.open = await loadSound('open.mp3');
                sounds.spike = await loadSound('spike.mp3');
                sounds.upgrade = await loadSound('upgrade.mp3');
                console.log('All sounds loaded successfully');
            } catch (e) {
                console.error('Error loading sounds:', e);
            }
        }

        // Инициализация звука при загрузке страницы
        initAudio();
        loadAllSounds();

        // Возобновление AudioContext после первого взаимодействия
        document.addEventListener('click', function() {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }, { once: true });

        // Функция переключения паузы
        function togglePause() {
            if (isPaused) {
                resumeGame();
            } else {
                pauseGame();
            }
        }

        // Функция постановки игры на паузу
        function pauseGame() {
            isPaused = true;
            isGameRunning = false;
            
            // Освобождаем курсор мыши
            if (document.pointerLockElement === document.body) {
                document.exitPointerLock();
            }
            
            // Показываем модальное окно паузы
            document.getElementById('pauseModal').style.display = 'flex';
            
            // Обновляем состояние переключателя звука
            document.getElementById('soundToggle').checked = soundEnabled;
        }

        // Функция возобновления игры
        function resumeGame() {
            isPaused = false;
            isGameRunning = true;
            
            // Скрываем модальное окно паузы
            document.getElementById('pauseModal').style.display = 'none';
            
            // Фиксируем курсор
            document.body.requestPointerLock();
        }

        // Функция отображения информации о комнате
        function showRoomInfo() {
            // Обновляем информацию о комнате
            document.getElementById('roomInfoTitle').textContent = `Комната ${roomNumber}`;
            document.getElementById('roomInfoGoal').textContent = `Цель: ${requiredFruits} фруктов`;
            document.getElementById('roomInfoTime').textContent = `Время: ${levelTime} секунд`;
            
            // Показываем модальное окно
            document.getElementById('roomInfoModal').style.display = 'flex';
            
            // Автоматически закрываем через 3 секунды
            setTimeout(() => {
                document.getElementById('roomInfoModal').style.display = 'none';
            }, 3000);
        }

        // Функция сохранения результата в таблицу лидеров
        function saveToLeaderboard() {
            // Получаем текущие результаты из localStorage
            let leaderboard = JSON.parse(localStorage.getItem('fruitCollectorLeaderboard')) || [];
            
            // Добавляем новый результат
            leaderboard.push({
                room: roomNumber,
                fruits: collectedFruits,
                time: levelTime,
                date: new Date().toISOString()
            });
            
            // Сортируем по номеру комнаты (убывание), затем по количеству фруктов (убывание)
            leaderboard.sort((a, b) => {
                if (a.room !== b.room) return b.room - a.room;
                return b.fruits - a.fruits;
            });
            
            // Оставляем только топ-10 результатов
            leaderboard = leaderboard.slice(0, 10);
            
            // Сохраняем в localStorage
            localStorage.setItem('fruitCollectorLeaderboard', JSON.stringify(leaderboard));
            
            return leaderboard;
        }

        // Функция отображения таблицы лидеров
        function displayLeaderboard() {
            const leaderboard = JSON.parse(localStorage.getItem('fruitCollectorLeaderboard')) || [];
            const leaderboardBody = document.getElementById('leaderboardBody');
            
            // Очищаем таблицу
            leaderboardBody.innerHTML = '';
            
            // Добавляем результаты
            leaderboard.forEach((entry, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${entry.room}</td>
                    <td>${entry.fruits}</td>
                    <td>${entry.time}с</td>
                `;
                leaderboardBody.appendChild(row);
            });
            
            // Показываем контейнер таблицы
            document.getElementById('leaderboardContainer').style.display = 'block';
        }

        function updatePlayer() {
            // Сохраняем предыдущую позицию для корректных проверок приземления
            prevPosition.copy(player.position);
            // Получаем направление взгляда камеры
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            
            // Проекция на горизонтальную плоскость
            cameraDirection.y = 0;
            cameraDirection.normalize();
            
            // Вычисляем перпендикулярное направление (вправо)
            const rightDirection = new THREE.Vector3().crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0)).normalize();
            
            // Вычисляем направление движения
            const moveDirection = new THREE.Vector3();
            
            if (keys['w']) {
                moveDirection.add(cameraDirection);
            }
            if (keys['s']) {
                moveDirection.sub(cameraDirection);
            }
            if (keys['a']) {
                moveDirection.sub(rightDirection);
            }
            if (keys['d']) {
                moveDirection.add(rightDirection);
            }
            if (keys['ц']) {
                moveDirection.add(cameraDirection);
            }
            if (keys['ы']) {
                moveDirection.sub(cameraDirection);
            }
            if (keys['ф']) {
                moveDirection.sub(rightDirection);
            }
            if (keys['в']) {
                moveDirection.add(rightDirection);
            }
            
            // Применяем ускорение в направлении движения
            if (moveDirection.length() > 0) {
                moveDirection.normalize();
                velocity.add(moveDirection.multiplyScalar(acceleration));
                
                // Если это первое движение, запускаем таймер
                if (!gameStarted) {
                    startGameTimer();
                    gameStarted = true;
                }
            }
            
            // Применяем трение
            velocity.multiplyScalar(friction);
            
            // Ограничиваем максимальную скорость
            if (velocity.length() > maxSpeed) {
                velocity.normalize().multiplyScalar(maxSpeed);
            }
            
            // Применяем движение по горизонтали
            player.position.add(velocity);
            
            // Применяем гравитацию и вертикальное движение
            verticalVelocity += gravity;
            player.position.y += verticalVelocity;
            
            // Проверка на землю с отскоком
            if (player.position.y <= playerRadius) {
                player.position.y = playerRadius;
                if (verticalVelocity < -minImpactSpeedForBounce) {
                    const impact = -verticalVelocity;
                    verticalVelocity = impact * groundBounceFactor;
                    triggerSquashStretch(impact);
                    if (verticalVelocity < minPostBounceSpeed) {
                        verticalVelocity = 0;
                        isJumping = false;
                        jumpCount = maxJumps;
                    }
                } else {
                verticalVelocity = 0;
                isJumping = false;
                jumpCount = maxJumps; // Сброс счетчика прыжков при приземлении
                }
            }
            
            // Проверка столкновений со стенами и отскок (внешние стены статичны и всегда присутствуют)
            if (player.position.x < -9) {
                player.position.x = -9;
                velocity.x = Math.abs(velocity.x) * bounceForce;
            }
            if (player.position.z < -9) {
                    player.position.z = -9;
                    velocity.z = Math.abs(velocity.z) * bounceForce;
            }
            if (player.position.x > 9) {
                player.position.x = 9;
                velocity.x = -Math.abs(velocity.x) * bounceForce;
            }
            if (player.position.z > 9) {
                    player.position.z = 9;
                    velocity.z = -Math.abs(velocity.z) * bounceForce;
            }
            
            // Вращение мяча в направлении движения (быстрее и в обратную сторону)
            if (velocity.length() > 0.01) {
                // Создаем ось вращения (перпендикулярно вектору движения и оси Y)
                const rotationAxis = new THREE.Vector3();
                rotationAxis.crossVectors(velocity, new THREE.Vector3(0, 1, 0)).normalize();
                
                // Угол вращения пропорционален скорости (увеличили с 0.1 до 0.3)
                const rotationAngle = -velocity.length() * 0.9; // Отрицательное значение для обратного вращения
                
                // Применяем вращение
                player.rotateOnWorldAxis(rotationAxis, rotationAngle);
            }
        }

        function updateCamera() {
            // Вектор направления взгляда, основанный на углах мыши
            const forward = new THREE.Vector3(
                -Math.sin(mouseX),
                Math.sin(mouseY),
                Math.cos(mouseX)
            ).normalize();
            
            const isFirstPerson = cameraDistance <= 0.6;
            if (isFirstPerson) {
                // Режим от первого лица: камера в центре шара по высоте
                const eye = new THREE.Vector3(
                    player.position.x,
                    player.position.y + playerRadius * 2, // чуть выше центра шара
                    player.position.z
                );
                // Ставим камеру немного позади и выше, чтобы видеть верх шара
                const camTarget = eye.clone()
                    .add(forward.clone().multiplyScalar(-2))
                    .add(new THREE.Vector3(0, 0.15, 0));
                // Сглаживание сильнее при больших вертикальных скоростях
                const vv = Math.abs(verticalVelocity || 0);
                const lerpFactor = Math.max(0.03, 0.18 / (1 + vv * 10));
                cameraSmoothPos.lerp(camTarget, lerpFactor);
                camera.position.copy(cameraSmoothPos);
                camera.lookAt(eye.clone().add(forward));
                // Шар видим
                if (!player.visible) player.visible = true;
            } else {
                // Третье лицо: используем дистанцию и высоту камеры
                let targetPosition = new THREE.Vector3(
                player.position.x + Math.sin(mouseX) * cameraDistance,
                player.position.y + cameraHeight + Math.sin(mouseY) * 5,
                player.position.z - Math.cos(mouseX) * cameraDistance
            );
                // Смещаем сильнее за мячом и чуть выше относительно направления взгляда
                targetPosition = targetPosition
                    .add(forward.clone().multiplyScalar(-0.7))
                    .add(new THREE.Vector3(0, 0.3, 0));
                const vv = Math.abs(verticalVelocity || 0);
                const lerpFactor = Math.max(0.04, 0.12 / (1 + vv * 10));
                cameraSmoothPos.lerp(targetPosition, lerpFactor);
                camera.position.copy(cameraSmoothPos);
            camera.lookAt(player.position);
                // Показываем шар
                if (!player.visible) player.visible = true;

                // Новая логика: вместо подъема камеры делаем стену за мячом прозрачной
                checkAndAdjustWallVisibility();
            }
        }

        // Новая функция для проверки и настройки видимости стен
        function checkAndAdjustWallVisibility() {
            // Сначала восстанавливаем прозрачность всех стен
            staticWalls.forEach(wall => {
                if (wall.userData.originalOpacity !== undefined) {
                    wall.material.opacity = wall.userData.originalOpacity;
                    wall.material.transparent = wall.userData.originalTransparent;
                    delete wall.userData.originalOpacity;
                    delete wall.userData.originalTransparent;
                }
            });
            
            // Проверяем, пересекает ли луч от камеры к игроку какие-либо стены
            const eyeToPlayer = new THREE.Ray(
                camera.position.clone(), 
                new THREE.Vector3().subVectors(player.position, camera.position).normalize()
            );
            
            let blockedWall = null;
            let minDistance = Infinity;
            
            // Находим ближайшую стену, блокирующую вид
            for (const wall of staticWalls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                const hitPoint = eyeToPlayer.intersectBox(wallBox, new THREE.Vector3());
                
                if (hitPoint) {
                    const distance = camera.position.distanceTo(hitPoint);
                    if (distance < minDistance) {
                        minDistance = distance;
                        blockedWall = wall;
                    }
                }
            }
            
            // Если найдена блокирующая стена, делаем ее прозрачной
            if (blockedWall) {
                // Сохраняем исходную прозрачность
                if (blockedWall.userData.originalOpacity === undefined) {
                    blockedWall.userData.originalOpacity = blockedWall.material.opacity;
                    blockedWall.userData.originalTransparent = blockedWall.material.transparent;
                }
                
                // Делаем стену полупрозрачной
                blockedWall.material.transparent = true;
                blockedWall.material.opacity = 0.3;
                blockedWall.material.needsUpdate = true;
            }
        }

        // Игровые переменные
        const fruits = [];
        let collectedFruits = 0;
        let requiredFruits = 5;
        let gate = null;
        let gateTrigger = null;
        let roomNumber = 1;
        let roomGroup = new THREE.Group();
        scene.add(roomGroup);
        // Статические стены для проверки видимости камеры
        const staticWalls = [];
        
        // Шипы
        const spikes = [];
        
        // Платформы
        const platforms = [];
        
        // Движущиеся платформы
        const movingPlatforms = [];
        // Запрещенные области для движущихся платформ (статичные платформы и миникомнаты)
        let forbiddenBoxes = [];
        
        // Внутренние комнаты
        const innerRooms = [];
        const innerWalls = []; // Массив для всех стен внутренних комнат
        
        // Усиления
        const powerUps = [];
        let activePowerUp = null;
        let powerUpTimer = 15;
        let powerUpInterval = null;
        
        // Таймер уровня
        let levelTime = 60; // Начальное время для первой комнаты
        let timerInterval = null;
        
        // Флаг для отслеживания начала игры
        let gameStarted = false;
        
        // Флаг для отслеживания состояния паузы
        let isPaused = false;

        // Функция проверки безопасности позиции
        function isPositionSafe(position, safeRadius = 1.5) {
            // Проверяем шипы
            for (const spike of spikes) {
                const distance = position.distanceTo(spike.position);
                if (distance < safeRadius) {
                    return false;
                }
            }
            // Проверяем стены (чтобы не в стене)
            if (position.x < -9 + safeRadius || position.x > 9 - safeRadius || 
                position.z < -9 + safeRadius || position.z > 9 - safeRadius) {
                return false;
            }
            // Проверяем внутренние стены
            for (const wall of innerWalls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                const playerSphere = new THREE.Sphere(position, playerRadius);
                if (wallBox.intersectsSphere(playerSphere)) {
                    return false;
                }
            }
            return true;
        }

        // Функция создания фрукта с текстурой
        function createFruitWithTexture(type) {
            const fruitGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            let fruitMaterial;
            
            try {
                let texture;
                switch(type) {
                    case 'apple':
                        texture = textureLoader.load('apple.jpg');
                        break;
                    case 'orange':
                        texture = textureLoader.load('orange.jpg');
                        break;
                    case 'pear':
                        texture = textureLoader.load('pear.jpg');
                        break;
                    default:
                        texture = null;
                }
                
                if (texture) {
                    fruitMaterial = new THREE.MeshStandardMaterial({ 
                        map: texture,
                        roughness: 0.7
                    });
                } else {
                    // Если текстура не загрузилась, используем цвет
                    let color;
                    switch(type) {
                        case 'apple':
                            color = 0xff0000;
                            break;
                        case 'orange':
                            color = 0xffa500;
                            break;
                        case 'pear':
                            color = 0x00ff00;
                            break;
                        default:
                            color = 0xffffff;
                    }
                    fruitMaterial = new THREE.MeshStandardMaterial({ 
                        color: color,
                        roughness: 0.7
                    });
                }
            } catch (e) {
                console.warn(`Failed to load texture for ${type}, using color`);
                let color;
                switch(type) {
                    case 'apple':
                        color = 0xff0000;
                        break;
                    case 'orange':
                        color = 0xffa500;
                        break;
                    case 'pear':
                        color = 0x00ff00;
                        break;
                    default:
                        color = 0xffffff;
                }
                fruitMaterial = new THREE.MeshStandardMaterial({ 
                    color: color,
                    roughness: 0.7
                });
            }
            
            const fruit = new THREE.Mesh(fruitGeometry, fruitMaterial);
            return fruit;
        }

        // Функция генерации комнаты
        function generateRoom() {
            // Построение неизменяемых объектов (пол и внешние стены) один раз
            if (!staticBuilt) {
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
                const floor = new THREE.Mesh(floorGeometry, sharedMaterials.floor);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
                staticGroup.add(floor);

            const wallHeight = 5;
            const wallThickness = 0.5;

            const backWall = new THREE.Mesh(
                new THREE.BoxGeometry(20, wallHeight, wallThickness),
                    sharedMaterials.wall
            );
            backWall.position.set(0, wallHeight / 2, -10);
            backWall.castShadow = true;
            backWall.receiveShadow = true;
            backWall.userData = { type: 'backWall' };
                staticGroup.add(backWall);
                staticWalls.push(backWall);

            const frontWall = new THREE.Mesh(
                new THREE.BoxGeometry(20, wallHeight, wallThickness),
                    sharedMaterials.wall
            );
            frontWall.position.set(0, wallHeight / 2, 10);
            frontWall.castShadow = true;
            frontWall.receiveShadow = true;
            frontWall.userData = { type: 'frontWall', removable: true };
                staticGroup.add(frontWall);
                staticWalls.push(frontWall);

            const leftWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, 20),
                    sharedMaterials.wall
            );
            leftWall.position.set(-10, wallHeight / 2, 0);
            leftWall.castShadow = true;
            leftWall.receiveShadow = true;
                leftWall.userData = { type: 'sideWall' };
                staticGroup.add(leftWall);
                staticWalls.push(leftWall);

            const rightWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, 20),
                    sharedMaterials.wall
            );
            rightWall.position.set(10, wallHeight / 2, 0);
            rightWall.castShadow = true;
            rightWall.receiveShadow = true;
                rightWall.userData = { type: 'sideWall' };
                staticGroup.add(rightWall);
                staticWalls.push(rightWall);

                staticBuilt = true;
            }

            // Сначала миникомнаты, чтобы остальные объекты их учитывали
            if (roomNumber >= 3) {
                createInnerRooms();
            }

            // Статичные платформы
            createPlatformsWithFruits();
            
            // Построим список запрещенных областей: статичные платформы + миникомнаты
            buildForbiddenBoxes();

            // Движущиеся платформы (учитывают forbiddenBoxes)
            createMovingPlatforms();
            
            // Шипы (учитывают innerRooms)
            createSpikes();
            
            // Создаем усиления
            createPowerUps();
            
            // Добавляем фрукты на пол для увеличения количества
            createFloorFruits();
            
            // Проверяем начальную позицию игрока
            let startPosition = new THREE.Vector3(0, playerRadius, 0);
            if (!isPositionSafe(startPosition)) {
                // Ищем безопасную позицию
                let foundSafePosition = false;
                for (let attempt = 0; attempt < 100; attempt++) {
                    const x = (Math.random() - 0.5) * 16; // в пределах комнаты, но не у стен
                    const z = (Math.random() - 0.5) * 16;
                    startPosition.set(x, playerRadius, z);
                    if (isPositionSafe(startPosition)) {
                        foundSafePosition = true;
                        break;
                    }
                }
                if (!foundSafePosition) {
                    // Если не нашли, ставим в центр, но выше (чтобы избежать шипов на полу)
                    startPosition.set(0, playerRadius + 1, 0);
                }
            }
            player.position.copy(startPosition);
        }

        // Функция создания фруктов на полу
        function createFloorFruits() {
            // Увеличиваем количество фруктов на полу в зависимости от номера комнаты
            const fruitCount = Math.max(3, roomNumber * 2);
            const fruitTypes = ['apple', 'orange', 'pear'];
            
            for (let i = 0; i < fruitCount; i++) {
                const type = fruitTypes[Math.floor(Math.random() * fruitTypes.length)];
                
                const fruit = createFruitWithTexture(type);
                fruit.position.set(
                    (Math.random() - 0.5) * 18,
                    0.3,
                    (Math.random() - 0.5) * 18
                );
                fruit.castShadow = true;
                fruit.receiveShadow = true;
                fruit.userData = { type: type, collected: false };
                
                roomGroup.add(fruit);
                fruits.push(fruit);
            }
        }

        // Функция создания шипов
        function createSpikes() {
            // Шипы на полу
            for (let i = 0; i < 5; i++) {
                const spikeGeometry = new THREE.ConeGeometry(0.2, 0.3, 4);
                const spikeMaterial = sharedMaterials.spike || new THREE.MeshStandardMaterial({ color: 0xff0000 });
                const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                
                let spikePlaced = false;
                let attempts = 0;
                
                while (!spikePlaced && attempts < 100) {
                    spikePlaced = true;
                    spike.position.set(
                        (Math.random() - 0.5) * 18,
                        0.15,
                        (Math.random() - 0.5) * 18
                    );
                    
                    // Проверяем, не находится ли шип внутри внутренней комнаты
                    for (const room of innerRooms) {
                        if (spike.position.x > room.x - room.width/2 && 
                            spike.position.x < room.x + room.width/2 &&
                            spike.position.z > room.z - room.depth/2 && 
                            spike.position.z < room.z + room.depth/2) {
                            spikePlaced = false;
                            break;
                        }
                    }
                    attempts++;
                }
                
                spike.castShadow = true;
                spike.userData = { 
                    type: 'spike',
                    radius: 0.1
                };
                
                roomGroup.add(spike);
                spikes.push(spike);
            }
            
            // Шипы на стенах
            for (let i = 0; i < 3; i++) {
                const spikeGeometry = new THREE.ConeGeometry(0.2, 0.3, 4);
                const spikeMaterial = sharedMaterials.spike || new THREE.MeshStandardMaterial({ color: 0xff0000 });
                const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                
                // Случайно выбираем стену
                const wall = Math.floor(Math.random() * 3);
                
                switch(wall) {
                    case 0: // Задняя стена
                        spike.position.set(
                            (Math.random() - 0.5) * 18,
                            Math.random() * 4 + 0.5,
                            -9.75
                        );
                        spike.rotation.z = Math.PI / 2;
                        break;
                    case 1: // Левая стена
                        spike.position.set(
                            -9.75,
                            Math.random() * 4 + 0.5,
                            (Math.random() - 0.5) * 18
                        );
                        spike.rotation.z = Math.PI / 2;
                        spike.rotation.y = Math.PI / 2;
                        break;
                    case 2: // Правая стена
                        spike.position.set(
                            9.75,
                            Math.random() * 4 + 0.5,
                            (Math.random() - 0.5) * 18
                        );
                        spike.rotation.z = Math.PI / 2;
                        spike.rotation.y = -Math.PI / 2;
                        break;
                }
                
                // Проверяем, не находится ли шип внутри внутренней комнаты
                for (const room of innerRooms) {
                    if (spike.position.x > room.x - room.width/2 && 
                        spike.position.x < room.x + room.width/2 &&
                        spike.position.z > room.z - room.depth/2 && 
                        spike.position.z < room.z + room.depth/2) {
                        // Перемещаем шип в другое место
                        let placed = false;
                        let attempts = 0;
                        while (!placed && attempts < 50) {
                            spike.position.set(
                                (Math.random() - 0.5) * 18,
                                0.15,
                                (Math.random() - 0.5) * 18
                            );
                            
                            // Проверяем, не внутри ли внутренней комнаты
                            let insideRoom = false;
                            for (const room of innerRooms) {
                                if (spike.position.x > room.x - room.width/2 && 
                                    spike.position.x < room.x + room.width/2 &&
                                    spike.position.z > room.z - room.depth/2 && 
                                    spike.position.z < room.z + room.depth/2) {
                                    insideRoom = true;
                                    break;
                                }
                            }
                            
                            if (!insideRoom) {
                                placed = true;
                            }
                            attempts++;
                        }
                        
                        spike.rotation.x = 0;
                        spike.rotation.z = 0;
                        spike.rotation.y = 0;
                        break;
                    }
                }
                
                spike.castShadow = true;
                spike.userData = { 
                    type: 'spike',
                    radius: 0.1
                };
                
                roomGroup.add(spike);
                spikes.push(spike);
            }
        }

        // Функция создания платформ с фруктами
        function createPlatformsWithFruits() {
            // Определяем количество платформ в зависимости от номера комнаты
            const platformCount = Math.min(3 + roomNumber, 8);
            // Все деревянные платформы на одном уровне, не касаются друг друга и стен
            const fixedHeight = 1.8; // общий уровень Y
            const minGap = 0.2; // минимальный зазор между платформами
            const placedBoxes = [];
            
            for (let i = 0; i < platformCount; i++) {
                // Создаем платформу
                const platformGeometry = new THREE.BoxGeometry(
                    Math.random() * 2 + 2,
                    0.2,
                    Math.random() * 2 + 2
                );
                
                const platformMaterial = sharedMaterials.wood;
                
                const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                
                // Размещаем на фиксированном уровне и следим за непересечением
                let attempts = 0;
                let positionFound = false;
                while (!positionFound && attempts < 200) {
                    const px = (Math.random() - 0.5) * 16;
                    const pz = (Math.random() - 0.5) * 16;
                    platform.position.set(px, fixedHeight, pz);
                    const halfW = platform.geometry.parameters.width / 2;
                    const halfD = platform.geometry.parameters.depth / 2;
                    const box = { minX: px - halfW - minGap, maxX: px + halfW + minGap, minZ: pz - halfD - minGap, maxZ: pz + halfD + minGap };
                    const touchesWall = box.minX <= -10 || box.maxX >= 10 || box.minZ <= -10 || box.maxZ >= 10;
                    let intersects = touchesWall;
                    for (const b of placedBoxes) {
                        if (!(box.maxX < b.minX || box.minX > b.maxX || box.maxZ < b.minZ || box.minZ > b.maxZ)) {
                            intersects = true;
                            break;
                        }
                    }
                    if (!intersects) {
                        positionFound = true;
                        placedBoxes.push(box);
                    }
                    attempts++;
                }
                platform.castShadow = true;
                platform.receiveShadow = true;
                platform.userData = { 
                    type: 'platform',
                    height: fixedHeight
                };
                
                roomGroup.add(platform);
                platforms.push(platform);
                
                // Создаем фрукт на платформе
                const fruitTypes = ['apple', 'orange', 'pear'];
                const type = fruitTypes[Math.floor(Math.random() * fruitTypes.length)];
                
                const fruit = createFruitWithTexture(type);
                fruit.position.set(
                    platform.position.x,
                    platform.position.y + 0.3,
                    platform.position.z
                );
                fruit.castShadow = true;
                fruit.receiveShadow = true;
                fruit.userData = { type: type, collected: false };
                
                roomGroup.add(fruit);
                fruits.push(fruit);
            }
        }

        // Построение запрещенных AABB: статические платформы и миникомнаты (расширяем на minGap)
        function buildForbiddenBoxes() {
            const minGap = 0.2;
            forbiddenBoxes = [];
            // Статичные платформы
            platforms.forEach(p => {
                const halfW = p.geometry.parameters.width / 2 + minGap;
                const halfD = p.geometry.parameters.depth / 2 + minGap;
                forbiddenBoxes.push({
                    minX: p.position.x - halfW,
                    maxX: p.position.x + halfW,
                    minZ: p.position.z - halfD,
                    maxZ: p.position.z + halfD
                });
            });
            // Миникомнаты (от рамок комнаты)
            innerRooms.forEach(r => {
                forbiddenBoxes.push({
                    minX: r.x - r.width / 2 - minGap,
                    maxX: r.x + r.width / 2 + minGap,
                    minZ: r.z - r.depth / 2 - minGap,
                    maxZ: r.z + r.depth / 2 + minGap
                });
            });
        }

        // Функция создания движущихся платформ
        function createMovingPlatforms() {
            // Определяем количество движущихся платформ
            const platformCount = Math.min(2 + Math.floor(roomNumber / 2), 5);
            const fixedHeight = 1.8; // тот же уровень, что и у статичных платформ
            const minGap = 0.2;
            const placedBoxes = [];
            
            for (let i = 0; i < platformCount; i++) {
                // Создаем платформу
                const platformGeometry = new THREE.BoxGeometry(
                    Math.random() * 1.5 + 1.5,
                    0.2,
                    Math.random() * 1.5 + 1.5
                );
                
                const platformMaterial = sharedMaterials.wood;
                
                const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                
                // Устанавливаем фиксированную высоту и безопасную начальную позицию
                let startX = 0, startZ = 0;
                let attempts = 0;
                while (attempts < 300) {
                    startX = (Math.random() - 0.5) * 14;
                    startZ = (Math.random() - 0.5) * 14;
                    const halfW = platformGeometry.parameters.width / 2;
                    const halfD = platformGeometry.parameters.depth / 2;
                    const box = { minX: startX - halfW - minGap, maxX: startX + halfW + minGap, minZ: startZ - halfD - minGap, maxZ: startZ + halfD + minGap };
                    const touchesWall = box.minX <= -10 || box.maxX >= 10 || box.minZ <= -10 || box.maxZ >= 10;
                    let intersects = touchesWall;
                    for (const b of placedBoxes) {
                        if (!(box.maxX < b.minX || box.minX > b.maxX || box.maxZ < b.minZ || box.minZ > b.maxZ)) {
                            intersects = true;
                            break;
                        }
                    }
                    // Проверка с запрещенными областями (статичные платформы и миникомнаты)
                    if (!intersects) {
                        for (const b of forbiddenBoxes) {
                            if (!(box.maxX < b.minX || box.minX > b.maxX || box.maxZ < b.minZ || box.minZ > b.maxZ)) {
                                intersects = true;
                                break;
                            }
                        }
                    }
                    if (!intersects) {
                        placedBoxes.push(box);
                        break;
                    }
                    attempts++;
                }
                
                platform.position.set(
                    startX,
                    fixedHeight,
                    startZ
                );
                
                // Определяем параметры движения
                const moveDirection = Math.random() > 0.5 ? 'x' : 'z';
                // Ограничиваем дистанцию так, чтобы платформа не выходила за границы
                const maxDistanceX = moveDirection === 'x' ? Math.min(4, 9 - Math.abs(startX) - 0.5) : 0;
                const maxDistanceZ = moveDirection === 'z' ? Math.min(4, 9 - Math.abs(startZ) - 0.5) : 0;
                const moveDistance = moveDirection === 'x' ? Math.max(1, maxDistanceX) : Math.max(1, maxDistanceZ);
                const moveSpeed = Math.random() * 0.02 + 0.01;
                
                platform.castShadow = true;
                platform.receiveShadow = true;
                platform.userData = { 
                    type: 'movingPlatform',
                    height: fixedHeight,
                    moveDirection: moveDirection,
                    moveDistance: moveDistance,
                    moveSpeed: moveSpeed,
                    startPosition: {
                        x: startX,
                        z: startZ
                    },
                    direction: 1, // 1 для движения вперед, -1 для движения назад
                    lastPos: { x: startX, z: startZ }
                };
                
                roomGroup.add(platform);
                movingPlatforms.push(platform);
                
                // Создаем фрукт на платформе
                const fruitTypes = ['apple', 'orange', 'pear'];
                const type = fruitTypes[Math.floor(Math.random() * fruitTypes.length)];
                
                const fruit = createFruitWithTexture(type);
                fruit.position.set(
                    platform.position.x,
                    platform.position.y + 0.3,
                    platform.position.z
                );
                fruit.castShadow = true;
                fruit.receiveShadow = true;
                fruit.userData = { 
                    type: type, 
                    collected: false,
                    onMovingPlatform: true,
                    platformIndex: movingPlatforms.length - 1
                };
                
                roomGroup.add(fruit);
                fruits.push(fruit);
            }
        }

        // Функция обновления движущихся платформ
        function updateMovingPlatforms() {
            movingPlatforms.forEach((platform, index) => {
                const data = platform.userData;
                // Запоминаем предыдущую позицию
                data.lastPos.x = platform.position.x;
                data.lastPos.z = platform.position.z;
                
                // Двигаем платформу в заданном направлении
                if (data.moveDirection === 'x') {
                    platform.position.x += data.moveSpeed * data.direction;
                    
                    // Проверяем, достигла ли платформа предела или границы комнаты
                    if (Math.abs(platform.position.x - data.startPosition.x) > data.moveDistance || platform.position.x <= -9 + 0.5 || platform.position.x >= 9 - 0.5) {
                        data.direction *= -1; // Меняем направление
                        // Возвращаем в допустимые пределы
                        platform.position.x = THREE.MathUtils.clamp(platform.position.x, -9 + 0.5, 9 - 0.5);
                    }
                } else {
                    platform.position.z += data.moveSpeed * data.direction;
                    
                    // Проверяем, достигла ли платформа предела или границы комнаты
                    if (Math.abs(platform.position.z - data.startPosition.z) > data.moveDistance || platform.position.z <= -9 + 0.5 || platform.position.z >= 9 - 0.5) {
                        data.direction *= -1; // Меняем направление
                        platform.position.z = THREE.MathUtils.clamp(platform.position.z, -9 + 0.5, 9 - 0.5);
                    }
                }

                // Проверяем пересечения с запрещенными областями и другими платформами (AABB
                const minGap = 0.2;
                const halfW = (platform.geometry.parameters.width) / 2 + minGap;
                const halfD = (platform.geometry.parameters.depth) / 2 + minGap;
                const box = { minX: platform.position.x - halfW, maxX: platform.position.x + halfW, minZ: platform.position.z - halfD, maxZ: platform.position.z + halfD };
                let collide = false;
                for (const b of forbiddenBoxes) {
                    if (!(box.maxX < b.minX || box.minX > b.maxX || box.maxZ < b.minZ || box.minZ > b.maxZ)) {
                        collide = true; break;
                    }
                }
                // Проверка с другими движущимися платформами
                if (!collide) {
                    for (let j = 0; j < movingPlatforms.length; j++) {
                        if (j === index) continue;
                        const other = movingPlatforms[j];
                        const oHalfW = other.geometry.parameters.width / 2 + minGap;
                        const oHalfD = other.geometry.parameters.depth / 2 + minGap;
                        const obox = { minX: other.position.x - oHalfW, maxX: other.position.x + oHalfW, minZ: other.position.z - oHalfD, maxZ: other.position.z + oHalfD };
                        if (!(box.maxX < obox.minX || box.minX > obox.maxX || box.maxZ < obox.minZ || box.minZ > obox.maxZ)) {
                            collide = true; break;
                        }
                    }
                }
                if (collide) {
                    // Откатываем и разворачиваем
                    platform.position.x = data.lastPos.x;
                    platform.position.z = data.lastPos.z;
                    data.direction *= -1;
                }
                
                // Обновляем позицию фрукта на платформе
                fruits.forEach(fruit => {
                    if (fruit.userData.onMovingPlatform && fruit.userData.platformIndex === index) {
                        fruit.position.x = platform.position.x;
                        fruit.position.z = platform.position.z;
                    }
                });
            });
        }

        // Функция создания внутренних комнат
        function createInnerRooms() {
            for (let i = 0; i < 2; i++) {
                const roomWidth = Math.random() * 3 + 3;
                const roomHeight = 3;
                const roomDepth = Math.random() * 3 + 3;
                
                // Стены внутренней комнаты
                let innerWallTexture;
                try {
                    innerWallTexture = textureLoader.load('stone.jpg');
                } catch (e) {
                    console.warn('Failed to load inner wall texture, using default');
                    innerWallTexture = null;
                }
                const wallMaterial = new THREE.MeshStandardMaterial({ 
                    map: innerWallTexture,
                    roughness: 0.9 
                });
                
                const wallThickness = 0.2;
                
                // Позиция комнаты
                const roomX = (Math.random() - 0.5) * 12;
                const roomZ = (Math.random() - 0.5) * 12;
                
                // Пол с текстурой травы
                const floorGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
                let floorTexture;
                try {
                    floorTexture = textureLoader.load('plate.jpg');
                } catch (e) {
                    console.warn('Failed to load grass texture, using default');
                    floorTexture = null;
                }
                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    map: floorTexture,
                    roughness: 0.8 
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.set(roomX, 0.1, roomZ);
                floor.receiveShadow = true;
                roomGroup.add(floor);
                
                // Потолок
                const ceilingGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
                const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
                const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
                ceiling.rotation.x = Math.PI / 2;
                ceiling.position.set(roomX, roomHeight, roomZ);
                ceiling.userData = { type: 'innerCeiling' };
                ceiling.receiveShadow = true;
                roomGroup.add(ceiling);
                
                // Стены
                // Задняя стена
                const backWall = new THREE.Mesh(
                    new THREE.BoxGeometry(roomWidth, roomHeight, wallThickness),
                    wallMaterial
                );
                backWall.position.set(roomX, roomHeight / 2, roomZ - roomDepth / 2);
                backWall.castShadow = true;
                backWall.receiveShadow = true;
                backWall.userData = { 
                    type: 'innerWall',
                    roomX: roomX,
                    roomZ: roomZ,
                    roomWidth: roomWidth,
                    roomDepth: roomDepth
                };
                roomGroup.add(backWall);
                innerWalls.push(backWall);
                
                // Передняя стена (с аркой)
                const archWidth = 1.5; // Ширина арки
                
                // Левая часть передней стены
                const frontWallLeft = new THREE.Mesh(
                    new THREE.BoxGeometry((roomWidth - archWidth) / 2, roomHeight, wallThickness),
                    wallMaterial
                );
                frontWallLeft.position.set(roomX - (roomWidth + archWidth) / 4, roomHeight / 2, roomZ + roomDepth / 2);
                frontWallLeft.castShadow = true;
                frontWallLeft.receiveShadow = true;
                frontWallLeft.userData = { 
                    type: 'innerWall',
                    roomX: roomX,
                    roomZ: roomZ,
                    roomWidth: roomWidth,
                    roomDepth: roomDepth
                };
                roomGroup.add(frontWallLeft);
                innerWalls.push(frontWallLeft);
                
                // Правая часть передней стены
                const frontWallRight = new THREE.Mesh(
                    new THREE.BoxGeometry((roomWidth - archWidth) / 2, roomHeight, wallThickness),
                    wallMaterial
                );
                frontWallRight.position.set(roomX + (roomWidth + archWidth) / 4, roomHeight / 2, roomZ + roomDepth / 2);
                frontWallRight.castShadow = true;
                frontWallRight.receiveShadow = true;
                frontWallRight.userData = { 
                    type: 'innerWall',
                    roomX: roomX,
                    roomZ: roomZ,
                    roomWidth: roomWidth,
                    roomDepth: roomDepth
                };
                roomGroup.add(frontWallRight);
                innerWalls.push(frontWallRight);
                
                // Верхняя часть передней стены (над аркой)
                const frontWallTop = new THREE.Mesh(
                    new THREE.BoxGeometry(roomWidth, roomHeight * 0.3, wallThickness),
                    wallMaterial
                );
                frontWallTop.position.set(roomX, roomHeight * 0.85, roomZ + roomDepth / 2);
                frontWallTop.castShadow = true;
                frontWallTop.receiveShadow = true;
                frontWallTop.userData = { 
                    type: 'innerWall',
                    roomX: roomX,
                    roomZ: roomZ,
                    roomWidth: roomWidth,
                    roomDepth: roomDepth
                };
                roomGroup.add(frontWallTop);
                innerWalls.push(frontWallTop);
                
                // Боковые стены
                const leftWall = new THREE.Mesh(
                    new THREE.BoxGeometry(wallThickness, roomHeight, roomDepth),
                    wallMaterial
                );
                leftWall.position.set(roomX - roomWidth / 2, roomHeight / 2, roomZ);
                leftWall.castShadow = true;
                leftWall.receiveShadow = true;
                leftWall.userData = { 
                    type: 'innerWall',
                    roomX: roomX,
                    roomZ: roomZ,
                    roomWidth: roomWidth,
                    roomDepth: roomDepth
                };
                roomGroup.add(leftWall);
                innerWalls.push(leftWall);
                
                const rightWall = new THREE.Mesh(
                    new THREE.BoxGeometry(wallThickness, roomHeight, roomDepth),
                    wallMaterial
                );
                rightWall.position.set(roomX + roomWidth / 2, roomHeight / 2, roomZ);
                rightWall.castShadow = true;
                rightWall.receiveShadow = true;
                rightWall.userData = { 
                    type: 'innerWall',
                    roomX: roomX,
                    roomZ: roomZ,
                    roomWidth: roomWidth,
                    roomDepth: roomDepth
                };
                roomGroup.add(rightWall);
                innerWalls.push(rightWall);
                
                // Сохраняем информацию о комнате
                innerRooms.push({
                    x: roomX,
                    z: roomZ,
                    width: roomWidth,
                    depth: roomDepth,
                    height: roomHeight
                });
                
                // 50% шанс, что в комнате будет фрукт
                if (Math.random() > 0.5) {
                    const fruitTypes = ['apple', 'orange', 'pear'];
                    const type = fruitTypes[Math.floor(Math.random() * fruitTypes.length)];
                    
                    const fruit = createFruitWithTexture(type);
                    fruit.position.set(
                        roomX + (Math.random() - 0.5) * (roomWidth - 1),
                        0.3,
                        roomZ + (Math.random() - 0.5) * (roomDepth - 1)
                    );
                    fruit.castShadow = true;
                    fruit.receiveShadow = true;
                    fruit.userData = { type: type, collected: false, inInnerRoom: true };
                    
                    roomGroup.add(fruit);
                    fruits.push(fruit);
                }
            }
        }

        // Функция создания усилений
        function createPowerUps() {
            const powerUpTypes = [
                { type: 'speed', texture: 'speed.png', name: 'Ускорение' },
                { type: 'grow', texture: 'scalability.png', name: 'Увеличение' },
                { type: 'shrink', texture: 'down.png', name: 'Уменьшение' }
            ];
            
            for (let i = 0; i < 3; i++) {
                const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                
                const powerUpGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
                let powerUpMaterial;
                
                try {
                    const texture = textureLoader.load(type.texture);
                    powerUpMaterial = new THREE.MeshStandardMaterial({ 
                        map: texture,
                        emissive: 0xffffff,
                        emissiveIntensity: 0.3,
                        roughness: 0.4
                    });
                } catch (e) {
                    console.warn(`Failed to load texture for ${type.type}, using color`);
                    let color;
                    switch(type.type) {
                        case 'speed':
                            color = 0x00ffff;
                            break;
                        case 'grow':
                            color = 0x00ff00;
                            break;
                        case 'shrink':
                            color = 0xff00ff;
                            break;
                        default:
                            color = 0xffffff;
                    }
                    powerUpMaterial = new THREE.MeshStandardMaterial({ 
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.5
                    });
                }
                
                const powerUp = new THREE.Mesh(powerUpGeometry, powerUpMaterial);
                
                powerUp.position.set(
                    (Math.random() - 0.5) * 18,
                    0.3,
                    (Math.random() - 0.5) * 18
                );
                powerUp.rotation.x = Math.PI / 2;
                powerUp.castShadow = true;
                powerUp.receiveShadow = true;
                powerUp.userData = { 
                    type: type.type, 
                    name: type.name,
                    collected: false,
                    baseY: 0.3, // Базовая высота для анимации
                    rotationSpeed: Math.random() * 0.02 + 0.01, // Скорость вращения
                    floatSpeed: 0.001, // Скорость плавания вверх-вниз
                    floatRange: 0.1 // Амплитуда плавания
                };
                
                roomGroup.add(powerUp);
                powerUps.push(powerUp);
            }
        }

        // Функция анимации усилений
        function animatePowerUps() {
            powerUps.forEach(powerUp => {
                if (!powerUp.userData.collected) {
                    // Вращение вокруг своей оси
                    powerUp.rotation.z += powerUp.userData.rotationSpeed;
                    
                    // Плавание вверх-вниз
                    const time = Date.now() * powerUp.userData.floatSpeed;
                    powerUp.position.y = powerUp.userData.baseY + Math.sin(time) * powerUp.userData.floatRange;
                }
            });
        }

        // Функция активации усиления
        function activatePowerUp(type) {
            // Если уже есть активное усиление, деактивируем его
            if (activePowerUp) {
                deactivatePowerUp();
            }
            
            activePowerUp = type;
            powerUpTimer = 15;
            
            // Показываем уведомление
            showNotification(`Усиление: ${type.name} активировано!`);
            
            // Применяем эффекты усиления
            switch(type.type) {
                case 'speed':
                    maxSpeed = 0.4;
                    break;
                case 'grow':
                    player.scale.set(1.5, 1.5, 1.5);
                    playerRadius = 0.75;
                    break;
                case 'shrink':
                    player.scale.set(0.5, 0.5, 0.5);
                    playerRadius = 0.25;
                    break;
            }
            
            // Запускаем таймер
            if (powerUpInterval) {
                clearInterval(powerUpInterval);
            }
            
            powerUpInterval = setInterval(() => {
                powerUpTimer--;
                
                if (powerUpTimer <= 0) {
                    deactivatePowerUp();
                }
            }, 1000);
        }

        // Функция деактивации усиления
        function deactivatePowerUp() {
            if (!activePowerUp) return;
            
            // Возвращаем стандартные значения
            switch(activePowerUp.type) {
                case 'speed':
                    maxSpeed = 0.2;
                    break;
                case 'grow':
                    player.scale.set(1, 1, 1);
                    playerRadius = 0.5;
                    break;
                case 'shrink':
                    player.scale.set(1, 1, 1);
                    playerRadius = 0.5;
                    break;
            }
            
            activePowerUp = null;
            
            if (powerUpInterval) {
                clearInterval(powerUpInterval);
                powerUpInterval = null;
            }
        }

        // Функция создания ворот
        function createGate() {
            // Создаем ворота (только для визуализации)
            const gateGeometry = new THREE.BoxGeometry(3, 4, 0.5);
            let gateMaterial;
            
            try {
                const doorTexture = textureLoader.load('door.jpg');
                gateMaterial = new THREE.MeshStandardMaterial({ 
                    map: doorTexture,
                    roughness: 0.7
                });
            } catch (e) {
                console.warn('Failed to load door texture, using default');
                gateMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700 });
            }
            
            gate = new THREE.Mesh(gateGeometry, gateMaterial);
            gate.position.set(0, 2, 9.5);
            gate.visible = false;
            gate.castShadow = true;
            gate.receiveShadow = true;
            gate.userData = { type: 'gate', open: false };
            roomGroup.add(gate);
            
            // Создаем триггер для перехода на следующий уровень
            const triggerGeometry = new THREE.BoxGeometry(3, 4, 0.5);
            const triggerMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0 
            });
            gateTrigger = new THREE.Mesh(triggerGeometry, triggerMaterial);
            gateTrigger.position.set(0, 2, 9.5);
            gateTrigger.userData = { type: 'gateTrigger', active: false };
            roomGroup.add(gateTrigger);
        }

        // Функция открытия ворот
        function openGate() {
            // Делаем ворота видимыми и открытыми
            if (gate) {
                gate.visible = true;
                gate.userData.open = true;
            }
            
            // Активируем триггер
            if (gateTrigger) {
                gateTrigger.userData.active = true;
            }
            
            // Воспроизводим звук открытия ворот
            if (sounds.open && soundEnabled) {
                playSound(sounds.open);
            }
            
            // Показываем уведомление
            showNotification("Ворота открыты! Иди в следующую комнату!");
            
            console.log("Ворота открыты! Иди в следующую комнату!");
        }

        // Функция перехода в следующую комнату
        function nextRoom() {
            // Сохраняем текущую позицию игрока
            const savedPlayerPosition = player.position.clone();
            
            // Удаляем все объекты из текущей комнаты
            while(roomGroup.children.length > 0) {
                roomGroup.remove(roomGroup.children[0]);
            }
            
            // Очищаем массивы
            fruits.length = 0;
            spikes.length = 0;
            platforms.length = 0;
            movingPlatforms.length = 0;
            innerRooms.length = 0;
            innerWalls.length = 0;
            powerUps.length = 0;
            
            // Увеличиваем номер комнаты
            roomNumber++;
            
            // Увеличиваем количество необходимых фруктов
            requiredFruits = Math.min(5 + roomNumber * 2, 20);
            
            // Генерируем новую комнату
            generateRoom();
            createGate();
            
            // Сбрасываем счетчик фруктов
            collectedFruits = 0;
            
            // Восстанавливаем позицию игрока
            player.position.copy(savedPlayerPosition);
            if (!isPositionSafe(savedPlayerPosition)) {
                // Ищем безопасную позицию
                let foundSafePosition = false;
                for (let attempt = 0; attempt < 100; attempt++) {
                    const x = (Math.random() - 0.5) * 16;
                    const z = (Math.random() - 0.5) * 16;
                    player.position.set(x, playerRadius, z);
                    if (isPositionSafe(player.position)) {
                        foundSafePosition = true;
                        break;
                    }
                }
                if (!foundSafePosition) {
                    player.position.set(0, playerRadius + 1, 0);
                }
            }
            
            prevPosition.copy(player.position);
            velocity.set(0, 0, 0);
            verticalVelocity = 0;
            jumpCount = maxJumps;
            
            // Сбрасываем флаг начала игры
            gameStarted = false;
            
            // Обновление UI
            updateUI();
            
            // Показываем информацию о новой комнате
            showRoomInfo();
            
            console.log(`Комната ${roomNumber} сгенерирована!`);
        }

        // Функция запуска таймера уровня
        function startLevelTimer() {
            // Останавливаем предыдущий таймер
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            // Устанавливаем время для комнаты: 60 - (roomNumber-1)*5, но не менее 20
            levelTime = Math.max(20, 60 - (roomNumber-1)*5);
            
            // Запускаем новый таймер
            timerInterval = setInterval(() => {
                if (!isPaused) {
                    levelTime--;
                    updateUI();
                    
                    if (levelTime <= 0) {
                        clearInterval(timerInterval);
                        gameOver("Время вышло! Ты не успел завершить комнату вовремя.");
                    }
                }
            }, 1000);
            
            updateUI();
        }

        // Функция запуска таймера после первого движения
        function startGameTimer() {
            // Запускаем таймер уровня
            startLevelTimer();
        }

        // Функция обработки проигрыша
        function gameOver(message = "Вы коснулись шипов и потеряли весь прогресс!") {
            // Сохраняем результат в таблицу лидеров
            saveToLeaderboard();
            
            // Показываем модальное окно
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOverModal').style.display = 'flex';
            
            // Освобождаем курсор мыши
            if (document.pointerLockElement === document.body) {
                document.exitPointerLock();
            }
            
            // Останавливаем игру
            isGameRunning = false;
            
            // Останавливаем таймеры
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            if (powerUpInterval) {
                clearInterval(powerUpInterval);
            }
        }

        // Функция перезапуска игры
        function restartGame() {
            // Скрываем модальное окно
            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('pauseModal').style.display = 'none';
            
            // Очищаем текущую комнату
            while(roomGroup.children.length > 0) {
                roomGroup.remove(roomGroup.children[0]);
            }
            
            // Очищаем массивы
            fruits.length = 0;
            spikes.length = 0;
            platforms.length = 0;
            movingPlatforms.length = 0;
            innerRooms.length = 0;
            innerWalls.length = 0;
            powerUps.length = 0;
            
            // Сбрасываем все параметры игры
            roomNumber = 1;
            collectedFruits = 0;
            requiredFruits = 5;
            gameStarted = false;
            isPaused = false;
            
            // Сброс усиления и масштаба игрока
            if (activePowerUp) {
                deactivatePowerUp();
            }
            
            // Генерация первой комнаты
            generateRoom();
            createGate();
            
            // Позиция игрока
            player.position.set(0, playerRadius, 0);
            prevPosition.copy(player.position);
            velocity.set(0, 0, 0);
            verticalVelocity = 0;
            jumpCount = maxJumps;
            
            // Сброс камеры
            camera.position.set(0, 8, 12);
            camera.lookAt(0, 0, 0);
            mouseX = 0;
            mouseY = 0;
            cameraDistance = 10;
            cameraHeight = 8;
            
            // Обновление UI
            updateUI();
            
            // Показываем информацию о комнате
            showRoomInfo();
            
            // Запускаем игру
            isGameRunning = true;
            // фиксируем курсор после закрытия модалки Game Over
            document.body.requestPointerLock();
        }

        // Функция показа уведомлений
        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        // Обновление UI
        function updateUI() {
            document.getElementById('roomNumber').textContent = roomNumber;
            document.getElementById('collectedFruits').textContent = collectedFruits;
            document.getElementById('requiredFruits').textContent = requiredFruits;
            document.getElementById('timeLeft').textContent = levelTime;
            
            // Выделяем время, когда оно меньше 10 секунд
            if (levelTime <= 10) {
                document.getElementById('timeLeft').style.color = '#ff3333';
                document.getElementById('timeContainer').style.animation = 'pulse 1s infinite';
            } else {
                document.getElementById('timeLeft').style.color = '#ffcc00';
                document.getElementById('timeContainer').style.animation = 'none';
            }
        }

        // Проверка столкновений со стенами внутренних комнат
        function checkInnerRoomCollisions() {
            const playerPos = player.position;

            innerWalls.forEach(wall => {
                const wallBox = new THREE.Box3().setFromObject(wall);
                
                // Находим ближайшую точку на AABB стены к центру сферы
                const closestPoint = new THREE.Vector3(
                    THREE.MathUtils.clamp(playerPos.x, wallBox.min.x, wallBox.max.x),
                    THREE.MathUtils.clamp(playerPos.y, wallBox.min.y, wallBox.max.y),
                    THREE.MathUtils.clamp(playerPos.z, wallBox.min.z, wallBox.max.z)
                );

                const delta = new THREE.Vector3().subVectors(playerPos, closestPoint);
                const distance = delta.length();

                if (distance < playerRadius) {
                    // Определяем тип контакта (верх/низ/бок)
                    const eps = 1e-4;
                    const onTopFace = Math.abs(closestPoint.y - wallBox.max.y) < eps &&
                        playerPos.x >= wallBox.min.x - eps && playerPos.x <= wallBox.max.x + eps &&
                        playerPos.z >= wallBox.min.z - eps && playerPos.z <= wallBox.maxZ + eps;
                    const onBottomFace = Math.abs(closestPoint.y - wallBox.min.y) < eps &&
                        playerPos.x >= wallBox.min.x - eps && playerPos.x <= wallBox.max.x + eps &&
                        playerPos.z >= wallBox.minZ - eps && playerPos.z <= wallBox.maxZ + eps;

                    // Вычисляем нормаль и глубину проникновения
                    let normal;
                    if (onTopFace) {
                        normal = new THREE.Vector3(0, 1, 0);
                    } else if (onBottomFace) {
                        normal = new THREE.Vector3(0, -1, 0);
                    } else if (distance > 0) {
                        normal = delta.normalize();
                        // Для боковых контактов игнорируем небольшой вертикальный дрейф нормали
                        if (Math.abs(normal.y) > 0 && Math.abs(normal.y) < 0.5) {
                            normal.y = 0;
                            normal.normalize();
                        }
                    } else {
                        // Дегенератный случай: выбираем ближайшую ось боковой поверхности
                        const dxMin = Math.abs(playerPos.x - wallBox.min.x);
                        const dxMax = Math.abs(playerPos.x - wallBox.max.x);
                        const dzMin = Math.abs(playerPos.z - wallBox.minZ);
                        const dzMax = Math.abs(playerPos.z - wallBox.maxZ);
                        const minAxis = Math.min(dxMin, dxMax, dzMin, dzMax);
                        if (minAxis === dxMin) normal = new THREE.Vector3(1, 0, 0);
                        else if (minAxis === dxMax) normal = new THREE.Vector3(-1, 0, 0);
                        else if (minAxis === dzMin) normal = new THREE.Vector3(0, 0, 1);
                        else normal = new THREE.Vector3(0, 0, -1);
                    }

                    const penetration = playerRadius - (distance === 0 ? 0 : distance);
                    playerPos.add(new THREE.Vector3().copy(normal).multiplyScalar(penetration + 0.001));

                    // Обновляем скорости в зависимости от поверхности
                    if (onTopFace) {
                        // Приземление только если падали и были выше поверхности на предыдущем кадре
                        const wasAbove = (prevPosition.y - playerRadius) >= (wallBox.max.y - 0.02);
                        if (verticalVelocity <= 0 && wasAbove) {
                            playerPos.y = wallBox.max.y + playerRadius;
                            verticalVelocity = 0;
                            isJumping = false;
                            jumpCount = maxJumps;
                        }
                    } else if (onBottomFace) {
                        // Удар снизу
                        if (verticalVelocity > 0) {
                            verticalVelocity = Math.abs(verticalVelocity) * bounceForce;
                        }
                    } else {
                        // Боковые контакты: отражаем горизонтальные компоненты
                        if (Math.abs(normal.x) > Math.abs(normal.z)) {
                            velocity.x = -Math.sign(velocity.x || normal.x) * Math.abs(velocity.x) * bounceForce;
                        } else {
                            velocity.z = -Math.sign(velocity.z || normal.z) * Math.abs(velocity.z) * bounceForce;
                        }
                    }
                }
            });
        }

        // Проверка столкновений с платформами (полная твердость)
function checkPlatformCollisions(platform) {
    const halfW = (platform.geometry.parameters.width || platform.geometry.parameters.w || 0) / 2;
    const halfD = (platform.geometry.parameters.depth || platform.geometry.parameters.d || 0) / 2;
    const halfH = (platform.geometry.parameters.height || 0.2) / 2;
    
    const platformBox = new THREE.Box3().setFromObject(platform);
    const playerSphere = new THREE.Sphere(player.position, playerRadius);
    
    // Проверяем пересечение сферы игрока с bounding box платформы
    if (platformBox.intersectsSphere(playerSphere)) {
        // Находим ближайшую точку на AABB платформы к центру сферы
        const closestPoint = new THREE.Vector3(
            THREE.MathUtils.clamp(player.position.x, platformBox.min.x, platformBox.max.x),
            THREE.MathUtils.clamp(player.position.y, platformBox.min.y, platformBox.max.y),
            THREE.MathUtils.clamp(player.position.z, platformBox.min.z, platformBox.max.z)
        );
        
        // Вычисляем вектор от ближайшей точки к центру сферы
        const delta = new THREE.Vector3().subVectors(player.position, closestPoint);
        const distance = delta.length();
        
        if (distance < playerRadius) {
            // Нормализуем вектор
            if (distance > 0) {
                delta.normalize();
            } else {
                // Если центр сферы точно внутри AABB, выбираем направление по наибольшему проникновению
                const penetrationX = Math.min(player.position.x - platformBox.min.x, platformBox.max.x - player.position.x);
                const penetrationY = Math.min(player.position.y - platformBox.min.y, platformBox.max.y - player.position.y);
                const penetrationZ = Math.min(player.position.z - platformBox.min.z, platformBox.max.z - player.position.z);
                
                if (penetrationX <= penetrationY && penetrationX <= penetrationZ) {
                    delta.set(player.position.x < platform.position.x ? -1 : 1, 0, 0);
                } else if (penetrationY <= penetrationX && penetrationY <= penetrationZ) {
                    delta.set(0, player.position.y < platform.position.y ? -1 : 1, 0);
                } else {
                    delta.set(0, 0, player.position.z < platform.position.z ? -1 : 1);
                }
            }
            
            // Выталкиваем сферу из AABB
            const penetration = playerRadius - distance;
            player.position.add(new THREE.Vector3().copy(delta).multiplyScalar(penetration + 0.001));
            
            // Обрабатываем скорость в зависимости от направления столкновения
            if (Math.abs(delta.y) > 0.5) {
                // Столкновение сверху или снизу
                if (delta.y > 0) {
                    // Столкновение с верхом платформы
                    if (verticalVelocity < 0) {
                        if (verticalVelocity < -minImpactSpeedForBounce) {
                            const impact = -verticalVelocity;
                            verticalVelocity = impact * groundBounceFactor;
                            triggerSquashStretch(impact);
                            if (verticalVelocity < minPostBounceSpeed) {
                                verticalVelocity = 0;
                            }
                        } else {
                            verticalVelocity = 0;
                        }
                        isJumping = false;
                        jumpCount = maxJumps;
                    }
                } else {
                    // Столкновение с низом платформы - блокируем движение вверх
                    if (verticalVelocity > 0) {
                        verticalVelocity = -verticalVelocity * bounceForce;
                    }
                }
            } else {
                // Столкновение с боковой стороной
                if (Math.abs(delta.x) > Math.abs(delta.z)) {
                    velocity.x = -velocity.x * bounceForce;
                } else {
                    velocity.z = -velocity.z * bounceForce;
                }
            }
            
            // Если это движущаяся платформа, двигаем игрока вместе с ней
            if (platform.userData.type === 'movingPlatform') {
                if (platform.userData.moveDirection === 'x') {
                    player.position.x += platform.userData.moveSpeed * platform.userData.direction;
                } else {
                    player.position.z += platform.userData.moveSpeed * platform.userData.direction;
                }
            }
            
            return true; // Было столкновение
        }
    }
    
    return false; // Столкновения не было
}

        // Функция создания визуального эффекта при сборе фрукта
        function createFruitCollectEffect(fruit) {
            // Создаем частицы для эффекта сбора
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                // Используем цвет фрукта для частиц
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: fruit.material.color || 0xffffff,
                    transparent: true,
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(fruit.position);
                
                // Случайное направление для частицы
                const direction = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
                
                particle.userData = {
                    direction: direction,
                    life: 1.0
                };
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Анимация частиц
            function animateParticles() {
                let allDead = true;
                
                particles.forEach(particle => {
                    if (particle.userData.life > 0) {
                        allDead = false;
                        particle.position.add(particle.userData.direction);
                        particle.userData.life -= 0.02;
                        particle.material.opacity = particle.userData.life;
                        particle.scale.setScalar(particle.userData.life);
                    } else {
                        scene.remove(particle);
                    }
                });
                
                if (!allDead) {
                    requestAnimationFrame(animateParticles);
                }
            }
            
            animateParticles();
        }

        // Проверка столкновений
        // ОБНОВЛЕННАЯ ФУНКЦИЯ: Проверка всех столкновений
function checkCollisions() {
    const playerBox = new THREE.Box3().setFromObject(player);
    
    // Проверка столкновений с шипами
    spikes.forEach(spike => {
        // Используем Sphere для более точной коллизии
        const spikeSphere = new THREE.Sphere(
            new THREE.Vector3(spike.position.x, spike.position.y, spike.position.z),
            spike.userData.radius || 0.15
        );
        
        if (playerBox.intersectsSphere(spikeSphere)) {
            // Воспроизводим звук столкновения с шипом
            if (sounds.spike && soundEnabled) {
                playSound(sounds.spike);
            }
            gameOver();
        }
    });
    
    // --- НОВЫЙ БЛОК: Проверка столкновений со ВСЕМИ платформами ---
    // Объединяем статичные и движущиеся платформы для проверки
    const allPlatforms = platforms.concat(movingPlatforms);
    allPlatforms.forEach(platform => {
        checkPlatformCollisions(platform);
    });
    
    // Проверка столкновений с потолками внутренних комнат
    innerWalls.forEach(wall => {
        if (wall.userData.type === 'innerCeiling') {
            const ceilingBox = new THREE.Box3().setFromObject(wall);
            if (ceilingBox.intersectsBox(playerBox) && verticalVelocity >= 0) {
                player.position.y = wall.position.y - wall.geometry.parameters.height / 2 - playerRadius;
                verticalVelocity = -verticalVelocity * Math.max(bounceForce, groundBounceFactor);
            }
        }
    });
    
    // Проверка столкновений с внутренними стенами
    checkInnerRoomCollisions();
    
    // Проверка столкновений с фруктами
    fruits.forEach((fruit, index) => {
        if (!fruit.userData.collected) {
            // Создаем меньшую область коллизии для фрукта
            const fruitPosition = fruit.position;
            const fruitRadius = 0.15; // Уменьшенный радиус коллизии (меньше визуального размера)
            
            // Проверяем расстояние между игроком и фруктом
            const distance = player.position.distanceTo(fruitPosition);
            
            // Если расстояние меньше суммы радиусов игрока и фрукта
            if (distance < (playerRadius + fruitRadius)) {
                // Дополнительная проверка: игрок должен быть на том же уровне или выше фрукта
                // Это предотвратит сбор фруктов через платформу снизу
                if (player.position.y >= fruitPosition.y - playerRadius) {
                    // Визуальный эффект подбора
                    createFruitCollectEffect(fruit);

                    fruit.userData.collected = true;
                    roomGroup.remove(fruit);
                    collectedFruits++;
                    
                    // Воспроизводим звук сбора фрукта
                    if (sounds.collect && soundEnabled) {
                        playSound(sounds.collect);
                    }
                    
                    console.log(`Собран ${fruit.userData.type}! Всего: ${collectedFruits}`);
                    
                    // Обновление UI
                    updateUI();
                    
                    if (collectedFruits >= requiredFruits) {
                        openGate();
                    }
                }
            }
        }
    });
    
    // Проверка столкновений с усилениями
    powerUps.forEach((powerUp, index) => {
        if (!powerUp.userData.collected) {
            const powerUpBox = new THREE.Box3().setFromObject(powerUp);
            if (powerUpBox.intersectsBox(playerBox)) {
                powerUp.userData.collected = true;
                roomGroup.remove(powerUp);
                
                // Воспроизводим звук улучшения
                if (sounds.upgrade && soundEnabled) {
                    playSound(sounds.upgrade);
                }
                
                // Активируем усиление
                activatePowerUp({
                    type: powerUp.userData.type,
                    name: powerUp.userData.name
                });
                
                console.log(`Собрано усиление ${powerUp.userData.name}!`);
            }
        }
    });
}

        // Проверка перехода через ворота
        function checkGateTransition() {
            if (gateTrigger && gateTrigger.userData.active) {
                const playerBox = new THREE.Box3().setFromObject(player);
                const triggerBox = new THREE.Box3().setFromObject(gateTrigger);
                if (playerBox.intersectsBox(triggerBox)) {
                    nextRoom();
                }
            }
        }

        // Переменная для управления игровым циклом
        let isGameRunning = true;
        let prevPosition = new THREE.Vector3();

        // Анимация
        function animate() {
            requestAnimationFrame(animate);
            
            if (isGameRunning && !isPaused) {
                updatePlayer();
                updateCamera();
                updateMovingPlatforms();
                animatePowerUps();
                checkCollisions();
                checkGateTransition();
                updateSquash();
            }
            
            renderer.render(scene, camera);
        }

        // Обработчики кнопок модальных окон
        document.getElementById('restartButton').addEventListener('click', restartGame);
        document.getElementById('introOkButton').addEventListener('click', () => {
            document.getElementById('introModal').style.display = 'none';
            isGameRunning = true;
            document.body.requestPointerLock();
            showRoomInfo();
        });
        
        // Обработчики для модального окна паузы
        document.getElementById('resumeButton').addEventListener('click', resumeGame);
        document.getElementById('restartFromPauseButton').addEventListener('click', restartGame);
        document.getElementById('leaderboardButton').addEventListener('click', displayLeaderboard);
        
        // Обработчик для переключателя звука
        document.getElementById('soundToggle').addEventListener('change', (e) => {
            soundEnabled = e.target.checked;
        });

        // Инициализация первой комнаты
        generateRoom();
        createGate();

        // Обновление UI
        updateUI();

        // Запуск анимации
        animate();
        
        // Показываем интро при первом запуске
        const seen = localStorage.getItem('intro_seen');
        if (!seen) {
            isGameRunning = false;
            document.getElementById('introModal').style.display = 'flex';
            localStorage.setItem('intro_seen', '1');
        } else {
            // Если интро уже было показано, сразу показываем информацию о комнате
            showRoomInfo();
        }
    </script>
</body>
</html>